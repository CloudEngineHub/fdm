# Copyright (c) 2025, ETH Zurich (Robotic Systems Lab)
# Author: Pascal Roth
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Forward Dynamics Model specific randomization utilities."""

from __future__ import annotations

import math
import numpy as np
import torch
from typing import TYPE_CHECKING

from isaaclab.assets import Articulation, RigidObject
from isaaclab.managers import SceneEntityCfg
from isaaclab.utils.math import quat_apply_yaw, quat_from_euler_xyz, sample_uniform

from nav_tasks.mdp import FixGoalCommand, GoalCommand

from ..commands import MixedCommand

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedEnv, ManagerBasedRLEnv


def randomize_rigid_body_material_uniform_static_dynamic_friction(
    env: ManagerBasedEnv,
    env_ids: torch.Tensor | None,
    static_friction_range: tuple[float, float],
    dynamic_friction_range: tuple[float, float],
    restitution_range: tuple[float, float],
    num_buckets: int,
    asset_cfg: SceneEntityCfg,
    regular: bool = False,
):
    """Randomize the physics materials on all geometries of the asset.

    ..note ::
        Change to original function is that static friction is set to be equal to dynamic friction

    This function creates a set of physics materials with random static friction, dynamic friction, and restitution
    values. The number of materials is specified by ``num_buckets``. The materials are generated by sampling
    uniform random values from the given ranges.

    The material properties are then assigned to the geometries of the asset. The assignment is done by
    creating a random integer tensor of shape  (num_instances, max_num_shapes) where ``num_instances``
    is the number of assets spawned and ``max_num_shapes`` is the maximum number of shapes in the asset (over
    all bodies). The integer values are used as indices to select the material properties from the
    material buckets.

    .. attention::
        This function uses CPU tensors to assign the material properties. It is recommended to use this function
        only during the initialization of the environment. Otherwise, it may lead to a significant performance
        overhead.

    .. note::
        PhysX only allows 64000 unique physics materials in the scene. If the number of materials exceeds this
        limit, the simulation will crash.
    """
    # extract the used quantities (to enable type-hinting)
    asset: RigidObject | Articulation = env.scene[asset_cfg.name]

    if not isinstance(asset, (RigidObject, Articulation)):
        raise ValueError(
            f"Randomization term 'randomize_rigid_body_material' not supported for asset: '{asset_cfg.name}'"
            f" with type: '{type(asset)}'."
        )

    # resolve environment ids
    if env_ids is None:
        env_ids = torch.arange(env.scene.num_envs, device="cpu")
    else:
        env_ids = env_ids.cpu()

    # retrieve material buffer
    materials = asset.root_physx_view.get_material_properties()
    # sample material properties from the given ranges
    material_samples = np.zeros(materials[env_ids].shape)

    if regular and (static_friction_range[1] - static_friction_range[0]) != 0.0:
        material_samples[..., 0] = np.arange(
            static_friction_range[0],
            static_friction_range[1],
            step=(static_friction_range[1] - static_friction_range[0]) / env.num_envs,
        )[:, None]
    else:
        material_samples[..., 0] = np.random.uniform(*static_friction_range, size=(env.num_envs, 1))

    material_samples[..., 1] = material_samples[..., 0].copy()
    # material_samples[..., 1] = np.random.uniform(*dynamic_friction_range)
    material_samples[..., 2] = np.random.uniform(*restitution_range, size=(env.num_envs, 1))

    # create uniform range tensor for bucketing
    lo = np.array([static_friction_range[0], static_friction_range[0], restitution_range[0]])
    # lo = np.array([static_friction_range[0], dynamic_friction_range[0], restitution_range[0]])
    hi = np.array([static_friction_range[1], static_friction_range[1], restitution_range[1]])
    # hi = np.array([static_friction_range[1], dynamic_friction_range[1], restitution_range[1]])

    # to avoid 64k material limit in physx, we bucket materials by binning randomized material properties
    # into buckets based on the number of buckets specified
    for d in range(3):
        buckets = np.array([(hi[d] - lo[d]) * i / num_buckets + lo[d] for i in range(num_buckets)])
        material_samples[..., d] = buckets[
            np.clip(np.searchsorted(buckets, material_samples[..., d]), 0, num_buckets - 1)
        ]

    # update material buffer with new samples
    if isinstance(asset, Articulation) and asset_cfg.body_ids != slice(None):
        # obtain number of shapes per body (needed for indexing the material properties correctly)
        # note: this is a workaround since the Articulation does not provide a direct way to obtain the number of shapes
        #  per body. We use the physics simulation view to obtain the number of shapes per body.
        num_shapes_per_body = []
        for link_path in asset.root_physx_view.link_paths[0]:
            link_physx_view = asset._physics_sim_view.create_rigid_body_view(link_path)  # type: ignore
            num_shapes_per_body.append(link_physx_view.max_shapes)

        # sample material properties from the given ranges
        for body_id in asset_cfg.body_ids:
            # start index of shape
            start_idx = sum(num_shapes_per_body[:body_id])
            # end index of shape
            end_idx = start_idx + num_shapes_per_body[body_id]
            # assign the new materials
            # material ids are of shape: num_env_ids x num_shapes
            # material_buckets are of shape: num_buckets x 3
            materials[env_ids, start_idx:end_idx] = torch.from_numpy(material_samples[:, start_idx:end_idx]).to(
                dtype=torch.float
            )
    else:
        materials[env_ids] = torch.from_numpy(material_samples).to(dtype=torch.float)

    # apply to simulation
    asset.root_physx_view.set_material_properties(materials, env_ids)


def reset_root_state_center(
    env: ManagerBasedEnv,
    env_ids: torch.Tensor,
    asset_cfg: SceneEntityCfg = SceneEntityCfg("robot"),
):
    """Reset the asset root state to zero velocity, forward orientation and a linearly spaced position."""

    # extract the used quantities (to enable type-hinting)
    asset: RigidObject | Articulation = env.scene[asset_cfg.name]
    # get default root state
    root_states = asset.data.default_root_state[env_ids].clone()

    # positions (small perturbation to avoid spawning issues)
    torch.manual_seed(0)
    perturbation = torch.hstack([
        sample_uniform(-0.2, 0.2, (len(env_ids), 2), device=asset.device),
        torch.zeros((len(env_ids), 1), device=asset.device),
    ])
    perturbation[:, 2] = 0.1
    positions = root_states[:, :3] + env.scene.env_origins[env_ids] + perturbation
    # orientations
    num_env_origins = torch.unique(env.scene.env_origins, dim=0).shape[0]
    assets_per_origin = math.ceil(env.num_envs / num_env_origins)
    yaw_orientation = torch.linspace(-torch.pi, torch.pi, assets_per_origin + 1, device=env.device)[:-1]
    yaw_samples = yaw_orientation[env_ids % assets_per_origin]
    orientations = quat_from_euler_xyz(torch.zeros_like(yaw_samples), torch.zeros_like(yaw_samples), yaw_samples)

    # velocities
    velocities = root_states[:, 7:13]

    # set into the physics simulation
    asset.write_root_pose_to_sim(torch.cat([positions, orientations], dim=-1), env_ids=env_ids)
    asset.write_root_velocity_to_sim(velocities, env_ids=env_ids)


def reset_root_state_paper_plot(
    env: ManagerBasedEnv,
    env_ids: torch.Tensor,
    asset_cfg: SceneEntityCfg = SceneEntityCfg("robot"),
):
    """Reset the asset root state to zero velocity, forward orientation and a linearly spaced position."""

    # extract the used quantities (to enable type-hinting)
    asset: RigidObject | Articulation = env.scene[asset_cfg.name]
    # get default root state
    root_states = asset.data.default_root_state[env_ids].clone()

    torch.manual_seed(0)
    # orientations
    num_env_origins = torch.unique(env.scene.env_origins, dim=0).shape[0]
    assets_per_origin = math.ceil(env.num_envs / num_env_origins)
    yaw_orientation = torch.linspace(-torch.pi, torch.pi, assets_per_origin + 1, device=env.device)[:-1]
    yaw_samples = yaw_orientation[env_ids % assets_per_origin]
    yaw_samples = yaw_samples.view(num_env_origins, assets_per_origin).T.reshape(-1)
    orientations = quat_from_euler_xyz(torch.zeros_like(yaw_samples), torch.zeros_like(yaw_samples), yaw_samples)
    perturbation = quat_apply_yaw(
        orientations, torch.tensor([[0.5, 0.0, 0.1]], device=asset.device).repeat(len(env_ids), 1)
    )
    positions = root_states[:, :3] + env.scene.env_origins[env_ids] + perturbation

    # velocities
    velocities = root_states[:, 7:13]

    # set into the physics simulation
    asset.write_root_pose_to_sim(torch.cat([positions, orientations], dim=-1), env_ids=env_ids)
    asset.write_root_velocity_to_sim(velocities, env_ids=env_ids)


def reset_root_state_planner_paper_plot(
    env: ManagerBasedEnv,
    env_ids: torch.Tensor,
    asset_cfg: SceneEntityCfg = SceneEntityCfg("robot"),
):
    """Reset the asset root state to zero velocity, forward orientation and a linearly spaced position."""

    # extract the used quantities (to enable type-hinting)
    asset: RigidObject | Articulation = env.scene[asset_cfg.name]
    # get default root state
    root_states = asset.data.default_root_state[env_ids].clone()

    # orientations
    num_env_origins = torch.unique(env.scene.env_origins, dim=0).shape[0]
    assets_per_origin = math.ceil(env.num_envs / num_env_origins)
    if assets_per_origin == 1 and env.scene.env_origins.shape[0] == 5:
        print("[INFO] Using fixed perturbation for single asset per origin and 5 origins.")
        perturbatio_y = torch.tensor([1.0, 0.9, -1.5, -0.9, -1.0], device=env.device).unsqueeze(1)
        perturbation = torch.hstack(
            [torch.zeros_like(perturbatio_y), perturbatio_y, torch.tensor([[0.1]], device=env.device).repeat(5, 1)]
        )
    else:
        perturbatio_y = torch.linspace(1.0, -1.0, assets_per_origin, device=env.device).unsqueeze(1)
        perturbation = (
            torch.hstack([
                torch.zeros_like(perturbatio_y),
                perturbatio_y,
                torch.tensor([[0.1]], device=env.device).repeat(assets_per_origin, 1),
            ])[None, :, :]
            .repeat(num_env_origins, 1, 1)
            .reshape(-1, 3)
        )
    # perturbation = torch.tensor([[0.0, -1.0, 0.1], [0.0, 1.0, 0.1]], device=asset.device)[None, :, :].repeat(num_env_origins, 1, 1).reshape(-1, 3)
    positions = root_states[:, :3] + env.scene.env_origins[env_ids] + perturbation[env_ids]

    # set into the physics simulation
    asset.write_root_pose_to_sim(torch.cat([positions, root_states[:, 3:7]], dim=-1), env_ids=env_ids)
    asset.write_root_velocity_to_sim(root_states[:, 7:13], env_ids=env_ids)


###
# Planner Reset
###


def reset_robot_position_planner(
    env: ManagerBasedRLEnv,
    env_ids: torch.Tensor,
    yaw_range: tuple[float, float],
    velocity_range: dict[str, tuple[float, float]],
    asset_cfg: SceneEntityCfg = SceneEntityCfg("robot"),
    goal_command_generator_name: str = "goal_command",
    spawn_in_env_frame: bool = False,
):
    """Reset the asset root state to the spawn state defined by the command generator.

    Args:
        env: The environment object.
        env_ids: The environment ids to reset.
        asset_cfg: The asset configuration to reset. Defaults to SceneEntityCfg("robot").
    """
    # extract the used quantities (to enable type-hinting)
    asset: Articulation = env.scene[asset_cfg.name]
    if isinstance(env.command_manager.get_term(goal_command_generator_name), GoalCommand | FixGoalCommand):
        goal_cmd_generator: GoalCommand = env.command_manager.get_term(goal_command_generator_name)  # type: ignore
    elif isinstance(env.command_manager.get_term(goal_command_generator_name), MixedCommand):
        mixed_cmd_geneator: MixedCommand = env.command_manager.get_term(goal_command_generator_name)  # type: ignore
        goal_cmd_generator: GoalCommand = mixed_cmd_geneator.get_subterm("planner")  # type: ignore
    # elif isinstance(env.command_manager.get_term(goal_command_generator_name), FixGoalCommand):
    #     positions = asset.data.default_root_state[env_ids, :3] + torch.randn((len(env_ids), 3), device=asset.device) * 0.1
    else:
        raise ValueError(f"Command type {type(env.command_manager._terms['command'])} not supported.")

    # positions - based on given start points (command generator)
    positions = asset.data.default_root_state[env_ids, :3].clone()
    positions += goal_cmd_generator.pos_spawn_w[env_ids]
    if spawn_in_env_frame:
        positions += env.scene.env_origins[env_ids]

    # yaw range
    yaw_samples = sample_uniform(yaw_range[0], yaw_range[1], (len(env_ids), 1), device=asset.device)
    yaw_samples += goal_cmd_generator.heading_spawn_w[env_ids].unsqueeze(1)
    orientations = quat_from_euler_xyz(
        torch.zeros_like(yaw_samples), torch.zeros_like(yaw_samples), yaw_samples
    ).squeeze(1)

    # velocities
    range_list = [velocity_range.get(key, (0.0, 0.0)) for key in ["x", "y", "z", "roll", "pitch", "yaw"]]
    ranges = torch.tensor(range_list, device=asset.device)
    rand_samples = sample_uniform(ranges[:, 0], ranges[:, 1], (len(env_ids), 6), device=asset.device)
    velocities = asset.data.default_root_state[env_ids, 7:13] + rand_samples

    # set into the physics simulation
    asset.write_root_pose_to_sim(torch.cat([positions, orientations], dim=-1), env_ids=env_ids)
    asset.write_root_velocity_to_sim(velocities, env_ids=env_ids)

    # obtain default joint positions
    default_joint_pos = asset.data.default_joint_pos[env_ids].clone()
    default_joint_vel = asset.data.default_joint_vel[env_ids].clone()
    # set into the physics simulation
    asset.write_joint_state_to_sim(default_joint_pos, default_joint_vel, env_ids=env_ids)
